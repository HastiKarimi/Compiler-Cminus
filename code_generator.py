# write functions for action symbols
# management stack and ...
# semantic
# change symbol table generated by scanner in the SymbolTable class
# parse change to call semantic analyzer and code generator
# create output file
"""
1    assign
1    declare_id         done
1    declare_array      done
1    push_type          done
2    do_op              done
2    mult               done
2    push_op            done
1    label              done
1    until              done
2    array_calc         done
2    jpf_save           done
2    save               done
2    jp                 done
1    print              done
1    push_num           done
2    id                 done
    add_scope ***
    counter ***
    counter_up ***
    break_check ***
    end_scope ***
    check_not_void ***
    end_func ***
    add_param ***
    end_func_params ***
"""

from symbol_table import SymbolTable
from heap_manager import HeapManager

kind_key = "kind"
type_key = "type"
address_key = "address"
scope_key = "scope"
attributes_key = "attributes"



def semantic_error(type, first_op, second_op="", third_op=""):
    print(f"semantic error: {first_op}, {second_op}, {third_op}")


class CodeGenerator:

    def __init__(self, symbol_table: SymbolTable, heap: HeapManager):
        self.symbol_table = symbol_table
        self.semantic_stack = []
        self.PB = []
        # pc shows the next line of program block to be filled (i in slides)
        self.PC = 0
        self.scope_stack = []
        self.heap_manager = heap

    def code_gen(self, action_symbol, token):
        if action_symbol == "declare_id":
            self.declare_id(token)
        elif action_symbol == "declare_array":
            pass

    def pop_last_n(self, n):
        # pop last n elements from semantic stack
        for _ in range(n):
            self.semantic_stack.pop()

    def program_block_insert(self, operation, first_op="", second_op="", third_op=""):
        # insert to program block
        operation = self.get_operation_by_symbol(operation)
        self.PB.append(f'{operation}, {first_op}, {second_op}, {third_op}')
        self.PC += 1

    def program_block_insert_empty(self):
        self.PB.append("")
        self.PC += 1

    def program_block_modification(self, index, operation, first_op="", second_op="", third_op=""):
        # modify a passed line of program block and add the code
        operation = self.get_operation_by_symbol(operation)
        self.PB[index] = f'{operation}, {first_op}, {second_op}, {third_op}'

    @staticmethod
    def get_operation_by_symbol(symbol):
        if symbol == '+':
            return "ADD"
        elif symbol == '-':
            return "SUB"
        elif symbol == '*':
            return "MULT"
        elif symbol == "==":
            return "EQ"
        elif symbol == "<":
            return "LT"
        elif symbol == ":=":
            return "ASSIGN"
        else:
            return symbol.toUpper()

    def push_type(self, token):
        # push type to stack
        if token == "int" or token == "void":
            self.semantic_stack.append(token)
        else:
            raise Exception("type not supported")

    def push_num(self, token):
        # push number to stack
        self.semantic_stack.append(int(token.strip()))

    def print(self, token):
        # TODO no idea yet
        pass

    def declare_id(self, token, kind="var"):
        # search in symbol table
        # if found in current scope raise error
        # if not found
        # add to symbol table
        # token will be the lexeme of the variable
        if self.symbol_table.lookup(token, self.scope_stack[-1]) != None:
            raise Exception("variable already declared")
        else:
            self.symbol_table.modify_last_row(kind=kind, type=self.semantic_stack[-1])
            self.semantic_stack.pop()

    def declare_array(self, token):
        # search in symbol table
        # if found in current scope raise error
        # if not found
        # add to symbol table
        if self.symbol_table.lookup(token, self.scope_stack[-1]) != None:
            raise Exception("variable already declared")
        else:
            self.symbol_table.modify_attributes_last_row(num_attributes=self.semantic_stack[-1])
            self.semantic_stack.pop()

    def assign(self, token):
        self.program_block_insert(operation=":=", first_op=self.semantic_stack[-1], second_op=self.semantic_stack[-2])
        self.pop_last_n(2)

    def label(self, token):
        # declare where to jump back after until in repeat-until
        self.semantic_stack.append(self.PC)

    def until(self, token):
        # jump back to label if condition is true
        self.program_block_insert(operation="JPF", first_op=self.semantic_stack[-1],
                                  second_op=self.semantic_stack[-2])
        self.pop_last_n(2)

    def mult(self, token):
        # multiply two numbers from top of the stack and push the result
        first_op = self.semantic_stack[-1]
        second_op = self.semantic_stack[-2]
        # todo semantic: check operands type
        op_type = self.symbol_table.get_row_by_address(first_op)[type_key]
        temp = self.heap_manager.get_temp(op_type)
        self.program_block_insert(operation="*", first_op=first_op,second_op=second_op,third_op=temp)
        self.pop_last_n(2)
        self.semantic_stack.append(temp)

    def array_calc(self, token):
        # calculate the address of the index of the array
        # the index is on top of the stack and the address of array is the second element
        # pop those two and push the address of calculated address to the stack
        array_address = self.semantic_stack[-2]
        array_type = self.symbol_table.get_row_by_address(array_address)[type_key]
        temp = self.heap_manager.get_temp(array_type)
        self.program_block_insert(
            operation="*",
            first_op=self.semantic_stack[-1],
            second_op=self.heap_manager.get_length_by_type(array_type),
            third_op=temp
        )
        self.program_block_insert(
            operation="+",
            first_op=array_address,
            second_op=temp,
            third_op=temp
        )
        self.pop_last_n(2)
        self.semantic_stack.append(temp)

    def push_op(self, token):
        # push operator to stack
        self.semantic_stack.append(token)

    def do_op(self, token):
        # do the operation
        # pop the operator and operands from the stack
        # push the result to the stack
        op = self.semantic_stack[-2]
        first_op = self.semantic_stack[-1]
        second_op = self.semantic_stack[-3]
        self.pop_last_n(3)
        temp = self.heap_manager.get_temp(self.symbol_table.get_row_by_address(first_op)[type_key])
        self.program_block_insert(operation=op, first_op=first_op, second_op=second_op, third_op=temp)
        self.semantic_stack.append(temp)

    def jpf_save(self, token):
        # jpf
        self.program_block_modification(
            index=self.semantic_stack[-1],
            operation="JPF",
            first_op=self.semantic_stack[-2],
            second_op=str(self.PC + 1)
        )
        self.pop_last_n(2)
        # then save current pc
        self.semantic_stack.append(self.PC)
        self.program_block_insert_empty()

    def save(self, toke):
        # save the current PC
        self.semantic_stack.append(self.PC)
        self.program_block_insert_empty()

    def jp(self, token):
        # jump to a label
        self.program_block_modification(
            index=self.semantic_stack[-1],
            operation="JP",
            first_op=str(self.PC)
        )
        self.pop_last_n(1)

    def id(self, token):
        # push the address of current token
        # todo semantic: check if variable is declared in our scope
        # todo how should we handle scope?
        address = self.symbol_table.lookup(token, self.scope_stack[-1])[address_key]
        self.semantic_stack.append(address)
# write functions for action symbols
                # management stack and ...
                # semantic
# change symbol table generated by scanner in the SymbolTable class
# parse change to call semantic analyzer and code generator
# create output file
'''
1    assign
1    declare_id - done
1    declare_array - done
1    push_type  - done
2    do_op
2    mult - done
2    push_op
1    label  - done
1    until  - done
2    array_calc - done
2    jpf_save
2    save
2    jp
1    print  - done
1    push_num   - done
2    id
    add_scope ***
    counter ***
    counter_up ***
    break_check ***
    end_scope ***
    check_not_void ***
    end_func ***
    add_param ***
    end_func_params ***
'''

from symbol_table import SymbolTable
from heap_manager import HeapManager

type_key = "type"

def semantic_error(type, first_op, second_op = "", third_op = ""):
    print(f"semantic error: {first_op}, {second_op}, {third_op}")


class code_generator:

    def __init__(self, symbol_table: SymbolTable, heap: HeapManager):
        self.symbol_table = symbol_table
        self.semantic_stack = []
        self.PB = []
        self.PC = 0
        self.scope_stack = []
        self.heap_manager = heap
        

    def code_gen(self, action_symbol, token):
        if action_symbol == "declare_id":
            self.declare_id(token)
        elif action_symbol == "declare_array":
            pass


    def pop_last_n(self, n):
        # pop last n elements from semantic stack
        for _ in range(n):
            self.semantic_stack.pop()

    def program_block_insert(self, operation, first_op = "", second_op = "", third_op = ""):
        # insert to program block
        self.PB.append(f'{operation}, {first_op}, {second_op}, {third_op}')
        self.PC += 1

    def program_block_modification(self, index, operation, first_op = "", second_op = "", third_op = ""):
        # modify a passed line of program block and add the code
        self.PB[index] = f'{operation}, {first_op}, {second_op}, {third_op}'


    def push_type(self, token):
        # push type to stack
        if token == "int" or token == "void":
            self.semantic_stack.append(token)
        else:
            raise Exception("type not supported")
        
    def push_num(self, token):
        # push number to stack
        self.semantic_stack.append(int(token.strip()))

    def print(self, token):
        # TODO no idea yet
        pass


    def declare_id(self, token, kind = "var"):
        # search in symbol table
        # if found in current scope raise error
        # if not found
        # add to symbol table
        # token will be the lexeme of the variable
        if self.symbol_table.lookup(token, self.scope_stack[-1]) != None:
            raise Exception("variable already declared")
        else:
            self.symbol_table.modify_last_row(kind=kind, type=self.semantic_stack[-1])
            self.semantic_stack.pop()


    def declare_array(self, token):
        # search in symbol table
        # if found in current scope raise error
        # if not found
        # add to symbol table
        if self.symbol_table.lookup(token, self.scope_stack[-1]) != None:
            raise Exception("variable already declared")
        else:
            self.symbol_table.modify_attributes_last_row(num_attributes=self.semantic_stack[-1])
            self.semantic_stack.pop()

    
    def assign(self, token):
        self.program_block_insert(operation=":=", first_op=self.semantic_stack[-1],second_op=self.semantic_stack[-2])
        self.pop_last_n(2)


    def label(self, token):
        # declare where to jump back after until in repeat-until
        self.semantic_stack.append(self.PC)

    def until(self, token):
        # jump back to label if condition is true
        self.program_block_insert(operation="JPF", first_op=self.semantic_stack[-1],
                                    second_op=self.semantic_stack[-2])
        self.pop_last_n(2)

    def mult(self, token):
        # multiply two numbers from top of the stack and push the result
        prod = self.semantic_stack[-1] * self.semantic_stack[-2]
        self.pop_last_n(2)
        self.semantic_stack.append(prod)

    def array_calc(self, token):
        # calculate the address of the index of the array
        # the index is on top of the stack and the address of array is the second element
        # pop those two and push the address of calculated address to the stack
        array_address = self.semantic_stack[-2]
        array_type = self.symbol_table.get_row_by_address(array_address)[type_key]
        temp = self.heap_manager.get_temp(array_type)
        self.program_block_insert(
            operation="*",
            first_op=self.semantic_stack[-1],
            second_op=self.heap_manager.get_length_by_type(array_type),
            third_op=temp
        )
        self.program_block_insert(
            operation="+",
            first_op=array_address,
            second_op=temp,
            third_op=temp
        )
        self.pop_last_n(2)
        self.semantic_stack.append(temp)
